# 你的 AI 記憶管理可能是錯的：為什麼該讓 Agent 學會「遺忘」

> 不是記不住，而是忘得不夠聰明

---

## 一個假想的災難場景

三個月前，你告訴你的 AI 助理：「我對蝦子過敏。」

昨天，你問它：「幫我推薦一家餐廳。」

它熱情地回覆：「這家海鮮餐廳很棒！他們的蒜蓉蒸蝦是招牌...」

**問題出在哪裡？**

你的 AI 記得你昨天隨口說的「今天好累」，卻忘記了三個月前可能攸關生死的過敏資訊。

這不是 bug，這是記憶管理的設計缺陷。

---

## 定時清垃圾桶的謬誤

大多數 AI Agent 的記憶管理長這樣：

```
寫入記憶 → 加上時間戳 → 定期掃描 → 超過30天刪除
```

看起來合理，對吧？

**問題是：垃圾桶不分貴重物品和廢紙。**

這種「一刀切」的清理邏輯，會導致兩個反效果的結果：

1. **高頻重要記憶被誤殺** —— 你反覆提到的偏好、長期有效的資訊，僅僅因為寫入時間早，就被清理掉
2. **低頻垃圾記憶佔空間** —— 臨時的抱怨、一次性的對話，因為剛寫入不久，反而佔據著實貴的記憶體空間

這就像把家裡的房契和昨天的購物小票一起扔進垃圾桶，然後定時倒垃圾——你永遠不知道會丟掉什麼。

---

## 人腦的啟示：為什麼我們該學會遺忘

中學時我們都學過**艾賓浩斯遺忘曲線**：

> 背一個單字，第一天忘60%，第三天忘75%。**但如果你第二天復習了一次，遺忘速度直接變慢。**

關鍵洞察：**人腦不是按時間遺忘，是按「不復習就遺忘」。**

經常被回憶的知識，在腦子裡「永遠年輕」；長期不被回憶的知識，自然衰減直到消失。

這個機制最優雅的地方：**不需要任何人工判斷。**

你不需要給記憶打標籤，系統不需要猜測哪條重要。**使用頻率本身就是最好的重要性信號。**

---

## 技術方案：給記憶加上「心率監測」

工程師 xiyu 提出了一個簡單而優雅的解決方案：**給每條記憶加一個 `ref` 字段。**

### 什麼是 ref？

`ref` = reference date = **這條記憶最後一次被實際使用是什麼時候**

**傳統格式：**
```
[2026-01-15] 用戶對蝦過敏
```

**新格式：**
```
[P1][2026-01-15][ref:2026-02-10] 用戶對蝦過敏
          ↑              ↑
       寫入日期      最後一次被引用
```

**淘汰邏輯的改變：**
- ❌ 舊做法：「寫入超過30天就刪」
- ✅ 新做法：「ref 距今超過30天就刪」

差別在哪裡？

- 三個月前寫入的過敏資訊，如果每次推薦餐廳都被引用 → ref 持續更新 → **永遠保留**
- 昨天寫入的「今天好累」，如果再也沒被提起 → ref 停留在昨天 → **30天後自動消失**

這才是「智能」的記憶管理。

---

## 三級優先級：不是所有記憶都該被遺忘

當然，有些資訊不該被遺忘曲線影響：

| 優先級 | 衰減規則 | 適用場景 |
|--------|---------|---------|
| **P0** | 永不自動淘汰 | 核心身份、安全規則、系統配置 |
| **P1** | ref 超過90天淘汰 | 用戶偏好、長期習慣、重要但非致命 |
| **P2** | ref 超過30天淘汰 | 臨時資訊、短期上下文、一次性指令 |

**用戶對蝦過敏** → P1，三個月沒被提到才可能被清理  
**今天好累** → P2，一個月沒被提到就清理  
**系統安全規則** → P0，永遠不清理

這樣的設計，既保證了重要資訊的長期保留，又讓臨時資訊自然衰減。

---

## 關鍵問題：什麼算「被引用」？

這裡有個大坑：**不是每次加載就算引用。**

很多 Agent 每次對話開始時會**批量加載**記憶到上下文。如果「加載」就算「引用」，那所有記憶的 ref 永遠是今天，衰減機制就廢了。

**真正的「引用」必須滿足：**
> 這條記憶**實際影響了 Agent 的輸出**

**實際判斷方法：**

1. **顯式引用** —— Agent 在回覆中明確提到：「您之前提到對蝦過敏，所以我推薦了這家店」
2. **檢索命中** —— 用 RAG 做記憶檢索時，這條記憶被召回並注入上下文
3. **決策依賴** —— Agent 的行為明顯受這條記憶影響（這個判斷成本高，一般用前兩種就夠）

**工程實踐建議：** 在 RAG 檢索召回時更新 ref。成本低，覆蓋率夠用。

---

## 向後兼容：舊系統怎麼辦？

你可能會問：「我現在有幾百條舊記憶，都沒有 ref 字段，怎麼辦？」

**優雅的解決方案：**
> 沒有 ref 的，拿**寫入日期**當 ref。

這意味著：
- 舊記憶會按寫入日期來判斷是否淘汰
- 如果一條舊記憶確實還在被使用，它會在下次被引用時獲得新的 ref，從此進入正常的衰減週期
- 如果它一直沒被引用——那它本來就該被清理

**不需要遷移，不需要批量更新，零成本過渡。**

---

## 實際效果：從定時炸彈到生態平衡

上了這套「基於引用頻率的衰減系統」後，會發生什麼變化？

### 變化 1：高頻記憶永遠保留
用戶反覆提到的偏好、經常用到的工具配置，ref 一直在刷新，永遠不會被淘汰。

### 變化 2：低頻記憶自然消失
那些「三個月前的天氣吐槽」「某天的臨時安排」，沒人引用，自動衰減掉。

### 變化 3：記憶池大小趨於穩定
不再是只增不減或者暴力清空。活躍記憶保留，僵尸記憶淘汰，總量在一個合理範圍波動。

### 變化 4：不需要人工干預
沒有人需要手動打標籤、手動清理、手動判斷哪條重要。**使用行為本身就是最好的篩選器。**

---

## 哲學思考：遺忘是認知效率的核心

做這套系統時，有個想法越來越強烈：

**AI 的記憶管理和人腦的差異，可能沒我們想象的那麼大。**

人腦不是硬盤，不會忠實存儲每一個細節。它一直在做篩選——用**遺忘**來篩選。被反覆調用的神經通路越來越強，不被調用的越來越弱，直到斷開。

這不是 bug，是 feature。**遺忘是認知效率的核心機制。**

AI Agent 的記憶管理，本質上也需要同樣的機制。無限存儲不是答案。你給一個 Agent 塞十萬條記憶，它的表現不會比精心維護的一千條好。

**信噪比才是關鍵，而遺忘是提高信噪比最自然的方式。**

---

## 給內容創作者的啟示

這個技術方案對內容創作也有啟發：

### 1. 你的內容「被引用」了嗎？
就像 AI 記憶的 ref 字段，你的文章有沒有被讀者真正「使用」？
- 被收藏但不讀 = 加載了但沒引用
- 被實際應用、分享、討論 = 真正的引用

### 2. 內容的「衰減週期」
- 時效性內容（如新聞快報）→ P2，短暫生命週期
- 深度分析（如趨勢預測）→ P1，長期價值
- 核心方法論（如思考框架）→ P0，永續價值

### 3. 遺忘的藝術
不是所有的內容都該被永遠記住。學會讓舊內容自然衰減，把注意力放在創造新的、值得被反覆引用的內容上。

---

## 行動清單

如果你正在使用或搭建 AI Agent 系統，可以這樣開始：

### 本週：評估現況
- [ ] 檢查你的記憶管理是否基於時間淘汰
- [ ] 評估是否有重要記憶被誤刪的風險
- [ ] 確認是否有僵尸記憶佔用空間

### 下週：實作 ref 字段
- [ ] 為新記憶添加 `ref` 字段追踪
- [ ] 設計三級優先級（P0/P1/P2）
- [ ] 修改淘汰邏輯從時間導向改為 ref 導向

### 本月：優化與調整
- [ ] 監控哪些記憶被淘汰，評估是否有誤殺
- [ ] 調整 P1/P2 的閾值（90天/30天可以根據實際情況調整）
- [ ] 考慮添加引用次數統計

---

## 結語：學會遺忘，才能記住重要的事

在這個信息爆炸的時代，記住一切是不可能的，也是不必要的。

無論是 AI Agent 還是人類，**認知效率的關鍵都不是「記住更多」，而是「忘得更聰明」。**

讓重要的資訊因為被反覆使用而永續，讓無用的資訊因為被忽視而自然消失。

這，才是最優雅的記憶管理。

---

**參考資源：**
- 技術方案來源：[xiyu (@ohxiyu)](https://x.com/ohxiyu/status/2022924956594806821)
- 相關閱讀：艾賓浩斯遺忘曲線、信噪比理論

---

*本文為《AI觀察日記》整理與深度分析。如果你喜歡這類結合技術與認知科學的內容，歡迎訂閱《AI未來週報》。*
